package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"context"
	"fmt"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"golang.org/x/crypto/bcrypt"

	"github.com/basit/fileshare-backend/auth"
	// "github.com/basit/fileshare-backend/auth/middleware"
	"github.com/basit/fileshare-backend/graph/model"
	"github.com/basit/fileshare-backend/initializers"
	"github.com/basit/fileshare-backend/models"
)

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, email string, password string) (*model.AuthPayload, error) {

	// Check if user exists
	var existing models.User
	if err := initializers.DB.Where("email = ?", email).First(&existing).Error; err == nil {
		return nil, fmt.Errorf("email already registered")
	}
	// Hash password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return nil, fmt.Errorf("failed to hash password: %v", err)
	}

	// Create user
	user := models.User{
		ID:           uuid.New(),
		Email:        email,
		PasswordHash: string(hashedPassword),
	}

	if err := initializers.DB.Create(&user).Error; err != nil {
		return nil, fmt.Errorf("failed to create user: %v", err)
	}

	// Generate JWT
	accessToken, _, err := auth.GenerateTokens(user.ID.String())
	if err != nil {
		return nil, err
	}

	return &model.AuthPayload{
		AccessToken: accessToken,
		User: &model.User{
			ID:    user.ID.String(),
			Email: user.Email,
			// Add other fields as needed
		},
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*model.AuthPayload, error) {
	var user models.User
	if err := initializers.DB.Where("email = ?", email).First(&user).Error; err != nil {
		return nil, fmt.Errorf("invalid email or password")
	}

	// Compare password using bcrypt (or whatever you use)
	if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(password)); err != nil {
		return nil, fmt.Errorf("invalid email or password")
	}

	accessToken, refreshToken, err := auth.GenerateTokens(user.ID.String())
	if err != nil {
		return nil, fmt.Errorf("failed to generate tokens: %v", err)
	}

	// Inside your resolver:
	ginContext, ok := ctx.Value("GinContextKey").(*gin.Context)
	if !ok {
		return nil, fmt.Errorf("could not get gin context")
	}
	http.SetCookie(ginContext.Writer, &http.Cookie{
		Name:     "refresh_token",
		Value:    refreshToken,
		HttpOnly: true,
		Secure:   true,
		Path:     "/api/refresh-token",
		SameSite: http.SameSiteStrictMode,
		Expires:  time.Now().Add(30 * 24 * time.Hour),
	})

	return &model.AuthPayload{
		AccessToken: accessToken,
		User: &model.User{
			ID:    user.ID.String(),
			Email: user.Email,
			// Add other fields as needed
		},
	}, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, token string) (*model.AuthPayload, error) {
	// Inside your resolver:
	ginContext, ok := ctx.Value("GinContextKey").(*gin.Context)
	if !ok {
		return nil, fmt.Errorf("could not get gin context")
	}
	cookie, err := ginContext.Request.Cookie("refresh_token")
	if err != nil {
		return nil, fmt.Errorf("refresh token not found")
	}

	userID, err := auth.ValidateToken(cookie.Value)

	if err != nil {
		return nil, fmt.Errorf("invalid refresh token")
	}

	accessToken, newRefreshToken, err := auth.GenerateTokens(userID)
	if err != nil {
		return nil, fmt.Errorf("failed to generate new tokens")
	}

	http.SetCookie(ginContext.Writer, &http.Cookie{
		Name:     "refresh_token",
		Value:    newRefreshToken,
		HttpOnly: true,
		Secure:   true,
		Path:     "/api/refresh-token",
		SameSite: http.SameSiteStrictMode,
		Expires:  time.Now().Add(30 * 24 * time.Hour),
	})

	var user models.User
	if err := initializers.DB.First(&user, "id = ?", userID).Error; err != nil {
		return nil, fmt.Errorf("user not found")
	}

	return &model.AuthPayload{
		AccessToken: accessToken,
		User: &model.User{
			ID:    user.ID.String(),
			Email: user.Email,
			// Add other fields as needed
		},
	}, nil
}
