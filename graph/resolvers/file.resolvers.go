package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"log"
	"os"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/basit/fileshare-backend/graph/model"
	"github.com/basit/fileshare-backend/initializers"
	"github.com/basit/fileshare-backend/models"
	"github.com/google/uuid"
	storage_go "github.com/supabase-community/storage-go"
)

// UploadFile is the resolver for the uploadFile field.
// UploadFile is the resolver for the uploadFile field.
func (r *mutationResolver) UploadFile(ctx context.Context, file graphql.Upload, fileName string, fileSize int32) (*model.File, error) {
	userID, _ := GetUserIDFromContext(ctx)

	supaURL := os.Getenv("SUPABASE_URL")
	supaKey := os.Getenv("SUPABASE_KEY")

	// Create storage client using the Storage-Go package
	storageClient := storage_go.NewClient(supaURL, supaKey, nil)

	uniqueID := uuid.New()
	// Read the file content
	fileBytes, err := io.ReadAll(file.File)
	if err != nil {
		return nil, fmt.Errorf("failed to read file: %v", err)
	}

	// Create a more organized path structure
	objectPath := fmt.Sprintf("public/%s/%s", uniqueID.String(), file.Filename)

	// Upload file using the Storage-Go client
	_, err = storageClient.UploadFile("fileshare", objectPath, bytes.NewReader(fileBytes))
	if err != nil {
		return nil, fmt.Errorf("upload to supabase failed: %v", err)
	}

	// Get the public URL
	publicURLResult := storageClient.GetPublicUrl("fileshare", objectPath)
	publicURL := publicURLResult.SignedURL

	var expiresAt time.Time
	if userID != nil {
		expiresAt = time.Now().Add(90 * 24 * time.Hour) // 3 months for authenticated users
	} else {
		expiresAt = time.Now().Add(24 * time.Hour) // 24 hours for anonymous users
	}

	dbFile := models.File{
		ID:           uniqueID,
		OriginalName: fileName,
		StoragePath:  objectPath,
		FileSize:     fileSize,
		DownloadSlug: uuid.New().String()[:8],
		CreatedAt:    time.Now(),
		ExpiresAt:    &expiresAt,
		UserID:       userID,
		PublicURL:    publicURL,
	}
	if err := initializers.DB.Create(&dbFile).Error; err != nil {
		return nil, fmt.Errorf("db error: %v", err)
	}

	return &model.File{
		ID:           dbFile.ID.String(),
		OriginalName: dbFile.OriginalName,
		StoragePath:  dbFile.StoragePath,
		FileSize:     dbFile.FileSize,
		DownloadSlug: dbFile.DownloadSlug,
		CreatedAt:    dbFile.CreatedAt.String(),
		ExpiresAt:    dbFile.ExpiresAt.String(),
		PublicURL:    dbFile.PublicURL,
	}, nil
}

// DeleteFile is the resolver for the deleteFile field.
func (r *mutationResolver) DeleteFile(ctx context.Context, fileID string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteFile - deleteFile"))
}

// RenameFile is the resolver for the renameFile field.
func (r *mutationResolver) RenameFile(ctx context.Context, fileID string, newName string) (*model.File, error) {
	panic(fmt.Errorf("not implemented: RenameFile - renameFile"))
}

// UpdateFileSettings is the resolver for the updateFileSettings field.
func (r *mutationResolver) UpdateFileSettings(ctx context.Context, fileID string, expiresAt *time.Time, password *string) (*model.File, error) {
	panic(fmt.Errorf("not implemented: UpdateFileSettings - updateFileSettings"))
}

// MyFiles is the resolver for the myFiles field.
func (r *queryResolver) MyFiles(ctx context.Context) ([]*model.File, error) {
	// Assuming you have user authentication and can get the userID from the context
	// This is a placeholder - replace with your actual auth logic
	// userID := getUserIDFromContext(ctx)
	userID := uuid.New() // Replace with actual user ID from context
	if userID == uuid.Nil {
		return nil, fmt.Errorf("user not authenticated")
	}

	// Query the database for files that belong to this user
	var dbFiles []models.File
	if err := initializers.DB.Where("user_id = ?", userID).Find(&dbFiles).Error; err != nil {
		return nil, fmt.Errorf("failed to fetch files: %v", err)
	}

	// Connect to Supabase storage to verify the files still exist
	supaURL := os.Getenv("SUPABASE_URL")
	supaKey := os.Getenv("SUPABASE_KEY")
	storageClient := storage_go.NewClient(supaURL+"/storage/v1", supaKey, nil)

	// Convert to GraphQL model type
	result := make([]*model.File, 0, len(dbFiles))
	for _, file := range dbFiles {
		// Optionally check if the file still exists in storage
		// You could skip this if it's a performance concern
		publicURL := storageClient.GetPublicUrl("fileshare", file.StoragePath)

		log.Printf("Checking file existence at: %s", publicURL.SignedURL)
		result = append(result, &model.File{
			ID:           file.ID.String(),
			OriginalName: file.OriginalName,
			StoragePath:  file.StoragePath,
			FileSize:     file.FileSize,
			DownloadSlug: file.DownloadSlug,
			CreatedAt:    file.CreatedAt.String(),
			// Add any other fields from your model
		})
	}

	return result, nil
}

// File is the resolver for the file field.
func (r *queryResolver) File(ctx context.Context, slug string) (*model.File, error) {
	panic(fmt.Errorf("not implemented: File - file"))
}

// PublicFile is the resolver for the publicFile field.
func (r *queryResolver) PublicFile(ctx context.Context, slug string) (*model.File, error) {
	panic(fmt.Errorf("not implemented: PublicFile - publicFile"))
}
