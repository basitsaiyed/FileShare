package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"context"
	"fmt"
	"log"
	"os"
	"time"

	"github.com/basit/fileshare-backend/graph/model"
	"github.com/basit/fileshare-backend/initializers"
	"github.com/basit/fileshare-backend/models"
	"github.com/google/uuid"
	storage_go "github.com/supabase-community/storage-go"
)

// UpdateFileSettings is the resolver for the updateFileSettings field.
func (r *mutationResolver) UpdateFileSettings(ctx context.Context, fileID string, expiresAt *time.Time, password *string) (*model.File, error) {
	panic(fmt.Errorf("not implemented: UpdateFileSettings - updateFileSettings"))
}

// MyFiles is the resolver for the myFiles field.
func (r *queryResolver) MyFiles(ctx context.Context) ([]*model.File, error) {
	// Assuming you have user authentication and can get the userID from the context
	// This is a placeholder - replace with your actual auth logic
	// userID := getUserIDFromContext(ctx)
	userID := uuid.New() // Replace with actual user ID from context
	if userID == uuid.Nil {
		return nil, fmt.Errorf("user not authenticated")
	}

	// Query the database for files that belong to this user
	var dbFiles []models.File
	if err := initializers.DB.Where("user_id = ?", userID).Find(&dbFiles).Error; err != nil {
		return nil, fmt.Errorf("failed to fetch files: %v", err)
	}

	// Connect to Supabase storage to verify the files still exist
	supaURL := os.Getenv("SUPABASE_URL")
	supaKey := os.Getenv("SUPABASE_KEY")
	storageClient := storage_go.NewClient(supaURL+"/storage/v1", supaKey, nil)

	// Convert to GraphQL model type
	result := make([]*model.File, 0, len(dbFiles))
	for _, file := range dbFiles {
		// Optionally check if the file still exists in storage
		// You could skip this if it's a performance concern
		publicURL := storageClient.GetPublicUrl("fileshare", file.StoragePath)

		log.Printf("Checking file existence at: %s", publicURL.SignedURL)
		result = append(result, &model.File{
			ID:           file.ID.String(),
			OriginalName: file.OriginalName,
			StoragePath:  file.StoragePath,
			FileSize:     file.FileSize,
			DownloadSlug: file.DownloadSlug,
			CreatedAt:    file.CreatedAt.String(),
			// Add any other fields from your model
		})
	}

	return result, nil
}

// File is the resolver for the file field.
func (r *queryResolver) File(ctx context.Context, slug string) (*model.File, error) {
	panic(fmt.Errorf("not implemented: File - file"))
}

// PublicFile is the resolver for the publicFile field.
func (r *queryResolver) PublicFile(ctx context.Context, slug string) (*model.File, error) {
	panic(fmt.Errorf("not implemented: PublicFile - publicFile"))
}

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func (r *mutationResolver) UploadFile(ctx context.Context, file graphql.Upload, fileName string, fileSize int32) (*model.File, error) {
	// Step 1: Get authenticated user
	userID, err := GetUserIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}

	// Step 2: Prepare storage
	slug := shortuuid.New() // or any slug generator
	storageFileName := fmt.Sprintf("%s_%s", time.Now().Format("20060102_150405"), file.Filename)
	storagePath := filepath.Join("uploads", storageFileName)

	out, err := os.Create(storagePath)
	if err != nil {
		return nil, fmt.Errorf("failed to create file: %w", err)
	}
	defer out.Close()

	_, err = io.Copy(out, file.File)
	if err != nil {
		return nil, fmt.Errorf("failed to write file: %w", err)
	}

	// Step 3: Create DB record
	publicURL := fmt.Sprintf("http://localhost:8080/%s", storagePath)
	dbFile := models.File{
		ID:           uuid.New(),
		OriginalName: fileName,
		StoragePath:  storagePath,
		FileSize:     fileSize,
		DownloadSlug: slug,
		PublicURL:    publicURL,
		UserID:       userID,
		CreatedAt:    time.Now(),
	}

	if err := initializers.DB.Create(&dbFile).Error; err != nil {
		return nil, fmt.Errorf("failed to save file record: %w", err)
	}

	// Step 4: Return GraphQL model
	return &model.File{
		ID:               dbFile.ID.String(),
		OriginalName:     dbFile.OriginalName,
		StoragePath:      dbFile.StoragePath,
		FileSize:         dbFile.FileSize,
		DownloadSlug:     dbFile.DownloadSlug,
		CreatedAt:        dbFile.CreatedAt.Format(time.RFC3339),
		ExpiresAt:        "",
		PublicURL:        dbFile.PublicURL,
		User:             &model.User{ID: userID.String()}, // basic user info
		DownloadCount:    int32(dbFile.DownloadCount),
		LastDownloadedAt: nil,
	}, nil
}
func (r *mutationResolver) DeleteFile(ctx context.Context, fileID string) (bool, error) {
	panic(fmt.Errorf("not implemented: DeleteFile - deleteFile"))
}
func (r *mutationResolver) RenameFile(ctx context.Context, fileID string, newName string) (*model.File, error) {
	panic(fmt.Errorf("not implemented: RenameFile - renameFile"))
}
*/
